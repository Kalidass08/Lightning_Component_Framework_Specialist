/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
'use strict';
// Node
const crypto = require('crypto');
const os = require('os');
const path = require('path');
const _ = require('lodash');
// Thirdparty
const Promise = require('bluebird');
// Local
const almError = require(path.join(__dirname, 'almError'));
const keyChainImpl = require(path.join(__dirname, 'keyChainImpl'));
const TAG_DELIMITER = ':';
const BYTE_COUNT_FOR_IV = 6;
const _algo = 'aes-256-gcm';
let _key = null;
const KEY_NAME = 'sfdx';
const _Keychain = keyChainImpl(os.platform());
/**
 * osxKeyChain promise wrapper.
 * @type {{get: KeychainPromises.get, set: KeychainPromises.set}}
 */
const KeychainPromises = {
    /**
     * Gets a password item
     * @param service - The keychain service name
     * @param account - The keychain account name
     */
    get(service, account) {
        return new Promise((resolve, reject) => {
            _Keychain.getPassword({ service, account }, (err, password) => {
                if (err) {
                    return reject(err);
                }
                return resolve({ username: account, password });
            });
        });
    },
    /**
     * Sets a generic password item in OSX keychain
     * @param service - The keychain service name
     * @param account - The keychain account name
     * @param password - The password for the keychain item
     */
    set(service, account, password) {
        return new Promise((resolve, reject) => {
            _Keychain.setPassword({ service, account, password }, (err) => {
                if (err) {
                    return reject(err);
                }
                return resolve({ username: account, password });
            });
        });
    }
};
/**
 * Crypto class for SFDX.
 * @param packageDotJson - Override object for package.json properties. Used for unit testing.
 * @constructor
 */
class Crypto {
    constructor() {
        let envVal = process.env.SFDX_DISABLE_ENCRYPTION;
        if (_.isString(envVal)) {
            envVal = envVal.toUpperCase();
        }
        const isDisabled = _.isBoolean(envVal) ? envVal : envVal === 'TRUE';
        this.enableTokenEncryption = !isDisabled;
    }
    /**
     * Initialize any crypto dependencies. In this case we need to generate an encryption key.
     * @param retried - I
     * @returns {*}
     */
    init(retried) {
        if (!this.enableTokenEncryption) {
            return Promise.resolve(null);
        }
        if (_key) {
            return Promise.resolve('ENCRYPTION_KEY_FOUND');
        }
        // First try and get a password from the OSX keychain.
        return KeychainPromises.get(KEY_NAME, 'local').then((savedKey) => {
            _key = savedKey.password;
            // Just want to have something returned. But I do not want to return the encryption key.
            return 'ENCRYPTION_KEY_FOUND';
        }).catch((err) => {
            // No password found
            if (!_.isNil(err) && err.name === 'PasswordNotFound') {
                // If we already tried to create a new key then bail.
                if (!_.isNil(retried)) {
                    throw err;
                }
                const key = crypto.randomBytes(Math.ceil(16)).toString('hex');
                // Create a new password in the KeyChain.
                return KeychainPromises.set(KEY_NAME, 'local', key)
                    .then(() => this.init(true));
            }
            else {
                throw err;
            }
        });
    }
    /**
     * Encrypts text.
     * @param text - The text to encrypt.
     * @returns {undefined|String} - If enableTokenEncryption is set to false or not defined in package.json then the text
     * is simply returned unencrypted.
     */
    encrypt(text) {
        if (_.isNil(text)) {
            return undefined;
        }
        if (!this.enableTokenEncryption) {
            return text;
        }
        if (_.isNil(_key)) {
            throw new Error('Failed to create a password in the OSX keychain.');
        }
        const iv = crypto.randomBytes(BYTE_COUNT_FOR_IV).toString('hex');
        const cipher = crypto.createCipheriv(_algo, _key, iv);
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        const tag = cipher.getAuthTag().toString('hex');
        return `${iv}${encrypted}${TAG_DELIMITER}${tag}`;
    }
    /**
     * Decrypts text.
     * @param text - The text to decrypt.
     * @returns {undefined|String} - If enableTokenEncryption is set to false or not defined in package.json then the text
     * is simply returned. The is then assumed to be unencrypted.
     */
    decrypt(text) {
        if (_.isNil(text)) {
            return undefined;
        }
        if (!this.enableTokenEncryption) {
            return text;
        }
        const tokens = text.split(TAG_DELIMITER);
        if (tokens.length !== 2) {
            throw almError('invalidEncryptedFormat', null, 'invalidEncryptedFormatAction', null);
        }
        const tag = tokens[1];
        const iv = tokens[0].substring(0, (BYTE_COUNT_FOR_IV * 2));
        const secret = tokens[0].substring((BYTE_COUNT_FOR_IV * 2), tokens[0].length);
        const decipher = crypto.createDecipheriv(_algo, _key, iv);
        let dec;
        try {
            decipher.setAuthTag(Buffer.from(tag, 'hex'));
            dec = decipher.update(secret, 'hex', 'utf8');
            dec += decipher.final('utf8');
        }
        catch (e) {
            throw almError('authDecryptFailed', [e.message]);
        }
        return dec;
    }
    close() {
        // No op for now. Can be used later to clean up the key. 
        // If the key is cleaned up, make sure this method is called
        // after reading all files from org:list.
    }
    // Primarily used for testing
    static reset() {
        _key = null;
    }
}
module.exports = Crypto;

//# sourceMappingURL=crypto.js.map
